# 1. while
- while문은 for문보다 간단하게 사용할 수 있는 반복문
- while(조건) {
    //반복적으로 실행될 소스코드

}
- 조건이 true면 반복하여 블록안의 소스코드를 실행
  ex) int num = 1;
      while(num <= 10){
       sum += num ++;

      }
- for문과 마찬가지로 조건이 false일 경우 반목문이 종료된다.
- for문과 다른점은 초기화식이나 증감식을 사용할 수 없다. 오직 조건식만 명시한다.

# 2. do-while
- do-while문은 while문과 다르게 조건과 상관없이 소스코드를 무조건 한 번 실행한 후 while의 조건식을 검사하기 시작
- do의 소스코드를 무조건 1회 실행한 후 while의 조건이 true일 때 반복적으로 실행
    ex) int sum = 0;
        int num = 1;
        do{
            sum += num++; // 무조건 1회 실행 후 조건이 true일 때 반복적으로 실행
        } while(num <= 100)

# 4. 중첩 반복문
- for문안에 for문을 다시 선언하여 반복시키는 형태
- for(){
    for() {

    }
} //2~9 까지 8번 반복
  for(int i = 2; 1 <= 9; i++){
    //1~9까지 9번 반복
    //i=2일 때 9번 반복(j=1 ~ j=9) 반복
    //안에 for문이 종료되면 다시 위의 for문으로 돌아가서 증감식 실행
    //i=3일 때 9번(j=1 ~ j=9) 반복
    for(int j = 1; j <= 9; j++){

    }
  }
  - 위의 for문의 조건이 true일 경우 안의 for문을 반복실행한 후 다시 위의 for문의 증감식을 돌아와서 조건을 비교한다.

  # 5. 반복문을 효과적으로 사용할 수 잇게 도와주는 continue, break
- continue문 : 반복문 안의 소스코드에서 comtinue를 만나게 되면 다시 반복문으로 돌아가서 for문의 증감식을 다시 실행, while문에서는 조건이 true인지 다시 검사
- break문 : 반복문을 종료시키는 구문. 반복문안의 소스코드에서 break문을 만나게 되면 현재 실행되고 있는 반복문을 종료시킴.

# 6. while문의 무한루프
- while(true) {

}
-  while( 1 > 0){

}
- 항상 true인 조건을 사용하게 되면 while문은 무한적으로 반복
- 무한 반복되는 while문을 종료시키기 위햐서 특정 조건에서 break문을 걸어준다.

# 7. 객체 지향 프로그래밍
- 객체지향 프로그래밍은 자바의 특징중 하나로써 객체(부품)을 만들어서 조립하는 과정을 통해 프로그래밍을 완성해가는 방식
- 객체(부품)을 만들기 위해서는 클래스(부품을 만드는 설계도)를 먼저 생성해야한다.
- 클래스(설계도)가 객체지향 프로그램의 핵심이 됩니다.
- 객체는 모든 사물이 객체의 대상이다. 객체는 고유의 속성과 기능을 가지고 있는 물체.
    ex) class 객체명 {
        속성들(변수)
        기능들(함수(메소드))

    }
- 객체의 속성들을 멤버변수라고 부르며, 기능들은 멤버 메소드나 멤버함수라고 부른다.


# 8. 기능에 해당하는 메소드
- 메소드는 기능하나를 수행하는 소스코드의 집합.
- 메소드를 만드는 방식 접근제어자(public, private, protected...) 반환타입(int, string, long, char.... 원시타입이나 클래스타입의 반환타입 지정) 메소드명(메소드에서 받아줄 인자변수(매개변수)){

    메소드에서 실해할 기능 소스코드
    return 반환타입의 값;
}

- 접근제어자 : 클래스, 변수, 메소드 앞에 지정할 수 있고 각각의 접근제어자에 따라서 접근할 수 있는 범위가 달라짐. 접근제어자는 생략하면 default 접근제어자로 인식.
- 접근제어자의 범위
    public > protected > default > private 범위 순서
    public : 같은 클래스 멤버, 같은 패키지에 속해있는 클래스, 자식(해당 클래스를 상속받은)클래스, 그외의 모든 영역에서 접근이 가능한 접근 제어자
    protected : 같은 클래스 멤버, 같은 패키지에 속해있는 클래스. 자식(해당 클래스를 상속받은)클래스에서 접근이 가능
    default : 같은 클래스 멤버, 같은 패키지에 속해있는 클래스에서 접근 가능
    private : 같은 클래스의 멤버에서 접근 가능.
- 반환타입 : 메소드가 종료된 후 메소드를 호출한 부분에 넘겨줄 값의 타입.
    void : 반환타입이 없을 때 사용
    int, long, char, 클래스... : 해당 형태의 값을 return해줘야 한다.
- 매개변수 : 메소드에서 호출하는 영역에서 메소드에 값을 전달하기 위해 미리 메소드 선언 시 정의해놓은 변수, 항상 호출하는 부분에서는 메소드에 정의되어 있는 매개변수의 타입과 개수, 순서는 맞춰야된다.
    ex) public int add(int a, int b){
        return a + b;

    }
    //메소드에 정의되어 있는 매개변수의 타입, 개수, 순서를 맞춰야한다.
    add(1, 3);
- 같은 이름과 같은 매개변수를 갖는 메소드는 한 번만 생성할 수 있다.
- 같은 이름의 매개변수의 타입이나 개수가 다르게 만들어지는 매소드들을 오버로딩이라 칭한다.
    ex) public int add(int a, int b){

    }
    -> 오버로딩(다른 메소드로 인식)
    public int add(int a, int b, int c){

    }

# 9. 클래스와 참조타입
- 클래스를 인스턴스화하여 객체(부품)으로 만들 수 있는데 이 때 객체를 담아주는 개체변수는 stack 영역에 생성되고 생성된 객체는 heap메모리 영역에 생성된다.
- stack 메모리 영역에 생성된 객체변수의 값은 heap 메모리 영역에 생성된 객채의 메모리 주소를 값으로 가지고 있다.
- 따라서 객체변수는 heap 메모리의 주소 값을 참조하여 객체를 꺼내올 수 있는 데 메모리 주소를 참조하여 사용하기 때문에 참조변수라고 부른다.


# 10. static 메모리 영역
- static 으로 선언된 변수와 메소드 그리고 전역변수는 static 메모리 영역에 저장된다.
- static 메모리 영역에 저장된 변수와 메소드는 프로그램 시작부터 종료때까지 삭제되지 않고 유지된다. 즉 Garbage Collector에서 벗어나게된다.
- 따라서 static 메모리 영역에 저장된 변수나 메소드가 많을수록 프로그램 구동 시 많은 메모리를 계속해서 사용하게 된다.
   static 변수와 메소드 그리고 전역변수는 프로그램 메모리에 지장이 가지 않도록 적당하게  생성해야 한다.
